# ApplicationContext 구현 개념 정리

## 1. `Reflections`

- **역할**: 지정한 패키지에서 `@Component` 붙은 클래스를 자동으로 스캔.
- **왜 필요?** → 일일이 수동 등록하지 않고, **자동 빈 등록**을 흉내내기 위해 사용.
- **여기서 하는 일**:

    ```java
    Reflections reflections = new Reflections(basePackage);
    this.components = reflections.getTypesAnnotatedWith(Component.class);
    ```


---

## 2. `Constructor` (리플렉션 생성자)

- **역할**: 클래스 생성자를 찾아 인스턴스를 동적으로 생성.
- **여기서 하는 일**:
    - `@Inject` 붙은 생성자가 있으면 → 그 생성자 사용.
    - 없으면 → 기본 생성자 사용.
- **코드**:

    ```java
    Constructor<?> ctor = selectConstructor(clazz);
    Object[] args = Arrays.stream(ctor.getParameterTypes())
            .map(this::resolveDependency) // 파라미터 타입에 맞는 빈 주입
            .toArray();
    ctor.setAccessible(true);
    Object instance = ctor.newInstance(args);
    ```


---

## 3. `Map<Class<?>, Object> beans`

- **역할**: 생성된 빈 객체들을 보관하는 인메모리 저장소.
- **스프링의 `ApplicationContext`와 같은 역할**.
- **코드**:

    ```java
    private final Map<Class<?>, Object> beans = new HashMap<>();
    ```


---

## 4. `getBean(Class<T> type)`

- **역할**: 원하는 타입의 빈을 꺼내오기.
- **동작 방식**:
    1. 동일 타입 있으면 바로 반환.
    2. 상위/인터페이스 타입 할당 가능 여부 확인.
    3. 아직 없으면 `@Component` 스캔된 후보에서 찾아 생성.
    4. 없으면 예외 발생.

---

## 5. 순환 참조 감지

- **문제**: `A` → `B` → `A` 같은 경우 무한 루프.
- **해결**: 생성 중인 클래스를 `creating` 집합에 기록 후, 중복되면 예외.

    ```java
    private final Set<Class<?>> creating = new HashSet<>();
    ```


---

## 6. 의존성 주입 (`resolveDependency`)

- **역할**: 생성자 파라미터 타입에 맞는 빈을 찾아 넣어줌.
- **동작**:
    - 이미 만들어진 빈 있으면 반환.
    - 없으면 새로 생성 시도.
    - 그래도 없으면 예외 발생.

---

## 정리

- `Reflections`: **후보 클래스 찾기**
- `Constructor`: **객체 생성**
- `beans`: **인메모리 저장소 (컨테이너)**
- `getBean`: **빈 조회 API**
- `creating`: **순환 참조 감지**
- `resolveDependency`: **DI 핵심 로직**